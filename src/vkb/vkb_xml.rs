//! Try to map as-is the xml(.fp3) file generated by VKBDevCfg's FastReport
//! There is NO processing/cleaning up/checks done here!
//! These are done by the next step see vkb_button.rs
//!
// TODO see also https://github.com/tafia/quick-xml/blob/master/examples/read_nodes_serde.rs

use std::path::PathBuf;

use quick_xml::events::Event;
use serde::Deserialize;

use super::VkbError;

/// Maps eg
/// <m7 t="0" h="32,12105"
/// u="&#60;font color=&#34;#000000&#34;&#62;Virtual button with SHIFT1 = 63&#13;&#10;Virtual button with SHIFT2 = 92" />
///
#[derive(Deserialize, Debug, Clone)]
pub(super) struct M7 {
    /// This is the description; xml escaped!
    #[serde(rename = "@u")]
    pub(super) desc_xml_escaped: String,
}

/// Maps the M5 child struct of "b2"
/// <m5 u="29" />
/// and is "Page0.LineN" which would seem to indicate this is only for ordering
/// BUT it maps nicely to the "physical button ID"???
#[derive(Deserialize, Debug, Clone)]
pub(super) struct M5 {
    /// This is the description; xml escaped!
    #[serde(rename = "@u")]
    pub(super) physical_button_id: String,
}

/// Maps eg
/// <b2 t="22,67718" h="32,12105">
///     <p2 t="0" w="113" h="22" ImageIndex="23" Transparent="1" />
///     <m7 t="0" h="32,12105"
///         u="&#60;font color=&#34;#000000&#34;&#62;Virtual button with SHIFT1 = 63&#13;&#10;Virtual button with SHIFT2 = 92" />
/// </b2>
///
/// NOTE: only care about "m7": <m7 name="Page0.Description1" />
/// "p2" is an image: <p2 name="Page0.Image1" />
#[derive(Deserialize, Debug, Clone)]
pub(super) struct B2 {
    #[serde(rename = "@t")]
    t: String,
    #[serde(rename = "@h")]
    h: String,
    /// The fields below SHOULD always be there, but sometimes a struct is split
    /// onto two pages
    /// grep for "<b2 t="1006,65661" h="8,11023377999998">" and "<b2 t="990,09462" h="34,15801">"
    pub(super) m5: Option<M5>,
    pub(super) m7: Option<M7>,
}

/// Maps the M3 child struct Virtual Button ID ("VBN" in VKB terminology)
/// <m8 u="95" />
#[derive(Deserialize, Debug, Clone)]
pub(super) struct M8 {
    /// This is the description; xml escaped!
    #[serde(rename = "@u")]
    pub(super) virtual_button_id: String,
}

/// Maps the description for the M3 child struct
/// <m9 u="&#60;b&#62;#95 &#60;/b&#62; Joystick button : #95" />
#[derive(Deserialize, Debug, Clone)]
pub(super) struct M9 {
    /// This is the description; xml escaped!
    #[serde(rename = "@u")]
    pub(super) desc_xml_escaped: String,
}

/// Maps eg
/// <b3 t="560,72449" h="33,77953">
///     <s1 />
///     <p3 w="113" h="22" ImageIndex="12" Transparent="1" />
///     <m8 u="95" />
///     <s2 />
///     <m9 u="&#60;b&#62;#95 &#60;/b&#62; Joystick button : #95" />
///     <g2 Left="0" Top="4,22046999999998" Width="718,1107" Height="1,13385826771654"
///         ShowHint="false" BeginColor="12632256" Style="gsHorizontal" Color="10526880" />
// </b3>
///
/// NOTE: only care about
/// - "m8": <m8 name="Page0.VBN" /> -> the Virtual Button number?
/// - "m9": <m9 name="Page0.Decsription2" /> -> description field, same as "m7" for "b2" struct
#[derive(Deserialize, Debug, Clone)]
pub(super) struct B3 {
    #[serde(rename = "@t")]
    t: String,
    #[serde(rename = "@h")]
    h: String,
    pub(super) m8: M8,
    pub(super) m9: M9,
}

/// Intro segment, only on the first page0?
type B1 = ();
/// also only on the first page0; not sure what that is: "<TfrxNullBand Height="1046,92981" Left="0" Top="0" Width="718,1107" l="0" t="0" />"
type TfrxNullBand = ();
/// summary; only on the last page
type B4 = ();
type B5 = ();
type B6 = ();

/// To preserve the relative order fo b2/b3 we need an wrapper struct
/// thanks phind.com
#[derive(Deserialize, Debug)]
pub(super) enum Page0Item {
    b1(B1),
    TfrxNullBand(TfrxNullBand),
    b2(B2),
    b3(B3),
    b4(B4),
    b5(B5),
    b6(B6),
}

/// Maps the per-page structure of B2/B3
/// <page0>
///     <b2...>
///     <b3 ...>
///     <b3 ...>
///     <b2...>
///     ...
/// </page0>
#[derive(Deserialize, Debug)]
struct Page0 {
    /// Option b/c the last page only has b6,b4,b5
    #[serde(rename = "$value")]
    b: Option<Vec<Page0Item>>,
}

/// <previewpages>Page0,Page0,...</previewpages>
#[derive(Deserialize, Debug)]
struct PreviewPages {
    page0: Vec<Page0>,
}

/// Maps the full report eg
/// <?xml version="1.0" encoding="utf-8" standalone="no"?>
/// <preparedreport>
/// <previewpages>
///     <page0>
///         <b2 ...>
///         <b3 ...>
///         <b3 ...>
///         <b2 ...>
///     ...
///     </page0>
///     <page0>
///         <b2 ...>
///         <b3 ...>
///         <b3 ...>
///         <b2 ...>
///     ...
///     </page0>
///     ...
/// </previewpages>
/// ...
/// </preparedreport>
///
#[derive(Deserialize, Debug)]
pub(super) struct VkbReport {
    previewpages: PreviewPages,
}

/// A XML parsed button, matching a "b2" or "b3" xml field
/// this is mapped directly from the xml field, no logic, no checks, etc
///
/// The next step is done by src/vkb/vkb_button.rs
#[derive(Debug, Clone)]
pub(super) enum VkbXmlButton {
    B2(B2),
    B3(B3),
}

impl VkbReport {
    /// Parse a VKB .fp3 report (== .xml)
    // TODO remove feature "overlapped-lists" and add a wrapper for B2 + Optional<Vec<B3>>
    pub(super) fn new(xml_path: PathBuf) -> Result<Self, VkbError> {
        let xml_str = std::fs::read_to_string(xml_path).map_err(|_| VkbError::Unknown)?;

        // TODO
        let vkb_report: VkbReport = quick_xml::de::from_str(&xml_str).map_err(|err| {
            println!("report error: {:?}", err);
            VkbError::Unknown
        })?;

        Ok(vkb_report)
    }

    /// Return only the b2/b3 list of fields from the VKB report
    pub(super) fn get_all_buttons(&self) -> Vec<VkbXmlButton> {
        let mut vkb_buttons = vec![];

        for page in &self.previewpages.page0 {
            match &page.b {
                Some(page_items) => {
                    for page_item in page_items {
                        match page_item {
                            Page0Item::b2(b2) => vkb_buttons.push(VkbXmlButton::B2(b2.clone())),
                            Page0Item::b3(b3) => vkb_buttons.push(VkbXmlButton::B3(b3.clone())),
                            _ => {}
                        }
                    }
                }
                None => todo!(),
            }
        }

        vkb_buttons
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_M7() {
        let xml_str = r#"
        <m7 h="20,59895" u="&#60;b&#62;#9 (Fire 2-nd stage) &#60;/b&#62;&#60;b&#62;- Button with momentary action&#60;/b&#62;" />
        "#;

        quick_xml::de::from_str::<M7>(xml_str).unwrap();
    }

    #[test]
    fn test_parse_B2() {
        let xml_str = r#"
        <b2 t="991,09462" h="33,15801">
            <m4 u="7" />
            <m5 u="9" />
            <m6 u="[R2.1]" />
            <m7 h="20,59895"
                u="&#60;b&#62;#9 (Fire 2-nd stage) &#60;/b&#62;&#60;b&#62;- Button with momentary action&#60;/b&#62;" />
            <g1 Left="0" Top="6,22046999999998" Width="718,1107" Height="1,88976378"
                ShowHint="false" BeginColor="12632256" Style="gsHorizontal" Color="10526880" />
        </b2>
        "#;

        quick_xml::de::from_str::<B2>(xml_str).unwrap();
    }

    #[test]
    fn test_parse_M8() {
        let xml_str = r#"
        <m8 u="95" />
        "#;

        quick_xml::de::from_str::<M8>(xml_str).unwrap();
    }

    #[test]
    fn test_parse_M9() {
        let xml_str = r#"
        <m9 u="&#60;b&#62;#95 &#60;/b&#62; Joystick button : #95" />
        "#;

        quick_xml::de::from_str::<M9>(xml_str).unwrap();
    }

    #[test]
    fn test_parse_B3() {
        let xml_str = r#"
        <b3 t="560,72449" h="33,77953">
                <s1 />
                <p3 w="113" h="22" ImageIndex="12" Transparent="1" />
                <m8 u="95" />
                <s2 />
                <m9 u="&#60;b&#62;#95 &#60;/b&#62; Joystick button : #95" />
                <g2 Left="0" Top="4,22046999999998" Width="718,1107" Height="1,13385826771654"
                    ShowHint="false" BeginColor="12632256" Style="gsHorizontal" Color="10526880" />
            </b3>
        "#;

        quick_xml::de::from_str::<B3>(xml_str).unwrap();
    }

    #[test]
    fn test_parse_Page0() {
        let xml_str = r#"
        <page0>
            <b1 t="0" h="173,89765">
                <m1 u="www.vkb-sim.pro" />
                <p1 ImageIndex="1" Transparent="1" TransparentColor="-16777208" />
                <m2 h="155"
                    u="Report generated by VKB Device Configurator v0.92.51  01/05/2023   11:25:59&#13;&#10; &#13;&#10;Controller : VKB NJoy32 XT PRO  v2.122&#13;&#10; &#13;&#10;Number of logical buttons : 128&#13;&#10;Number of HATs : 1&#13;&#10;MOUSE - Not used&#13;&#10;Virtual Keyboard : Not used&#13;&#10;Multimedia Controls : Not used&#13;&#10;Windows system Controls : Not used" />
                <m3 u="" />
            </b1>
            <TfrxNullBand Height="1046,92981" Left="0" Top="0" Width="718,1107" l="0" t="0" />
            <b2 t="173,89765" h="45,55906">
                <p2 w="228" h="22" ImageIndex="2" Transparent="1" />
                <m4 u="Line" />
                <m5 u="1" />
                <m6 u="[R1.1]" />
                <m7 h="33"
                    u="&#60;b&#62;#1 (E1) &#60;/b&#62; / &#60;b&#62;#2  - Encoder 2/4&#60;/b&#62;&#13;&#10;Virtual buttons : #61 / #62" />
                <g1 Left="0" Top="6,22046999999998" Width="718,1107" Height="1,88976378"
                    ShowHint="false" BeginColor="12632256" Style="gsHorizontal" Color="10526880" />
            </b2>
            <b3 t="219,45671" h="33,77953">
                <s1 />
                <p3 w="113" h="22" ImageIndex="3" Transparent="1" />
                <m8 u="61" />
                <s2 />
                <m9 u="&#60;b&#62;#61 &#60;/b&#62; Joystick button : #61" />
                <g2 Left="0" Top="4,22046999999998" Width="718,1107" Height="1,13385826771654"
                    ShowHint="false" BeginColor="12632256" Style="gsHorizontal" Color="10526880" />
            </b3>
            <b5 t="1024,25263" />
        </page0>
        "#;

        quick_xml::de::from_str::<Page0>(xml_str).unwrap();
    }

    #[test]
    fn test_parse_ReportFull_simplified() {
        assert!(VkbReport::new(
            concat!(
                env!("CARGO_MANIFEST_DIR"),
                "/tests/data/vkb_report_simplified.fp3"
            )
            .into(),
        )
        .is_ok());
    }

    #[test]
    fn test_parse_ReportFull_full_R() {
        assert!(VkbReport::new(
            concat!(env!("CARGO_MANIFEST_DIR"), "/bindings/vkb_report_R.fp3").into(),
        )
        .is_ok());
    }

    #[test]
    fn test_parse_ReportFull_full_L() {
        assert!(VkbReport::new(
            concat!(env!("CARGO_MANIFEST_DIR"), "/bindings/vkb_report_L.fp3").into(),
        )
        .is_ok());
    }
}
